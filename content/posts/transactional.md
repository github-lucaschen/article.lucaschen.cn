---
title: '事务详解'
description: 'transactional'
keywords: 'transactional'

date: 2024-06-07T16:49:53+08:00

categories:
  - Database
tags:
  - MySQL
  - Transactional
---

介绍事务特征、并发问题、隔离级别、乐(悲)观锁、MVCC。

<!--more-->

## 事务的四大特征

1. **原子性（Atomicity）**：事务里的内容要么全部成功要么都不成功。
2. **一致性（Consistency）**：事务前后数据的完整性保持一致，如：a 给 b 转一千块，事务执行以后，a 和 b 的钱总数是一样的。
3. **隔离性（Isolation）**：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
   即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
4. **持久性（Durability）**：事务结束，数据就持久化到数据库。

## 并发事务问题

1. **脏读 (Dirty Read)**
   脏读发生在一个事务能够读取另一个事务尚未提交的数据时。如果第二个事务回滚（撤销）了这些更改，那么第一个事务读取到的数据就变得无效或“脏”了。脏读仅在最低的隔离级别“读未提交”（Read Uncommitted）下会发生。
   **示例**：
   - 事务 A 更新了一行数据，但未提交。
   - 事务 B 读取了这个更新的数据。
   - 事务 A 回滚了更新。
   - 事务 B 读取到的数据现在无效，因为事务 A 的更改没有最终被提交。
2. **不可重复读 (Non-Repeatable Read)**
   不可重复读问题出现在一个事务在两次读取同一数据时，数据发生了变化。这种情况通常发生在隔离级别“读已提交”（Read Committed）下。
   **示例**：
   - 事务 A 读取了一行数据。
   - 事务 B 更新了该行数据并提交。
   - 事务 A 再次读取同一行数据，发现数据已经发生变化。
3. **幻读 (Phantom Read)**
   幻读问题发生在一个事务执行两次相同的查询，但第二次查询返回的结果集包含了第一次查询时不存在的“幻影”行。这种情况通常发生在隔离级别“可重复读”（Repeatable Read）下，但可以在“串行化”（Serializable）级别避免。
   **示例**：
   - 事务 A 读取符合某个条件的多行数据。
   - 事务 B 插入了几行满足事务 A 查询条件的新数据并提交。
   - 事务 A 再次执行相同的查询，发现结果集中包含了新插入的行。

## 四种标准的事务隔离级别

在 MySQL 中，事务隔离级别定义了一个事务在读取数据时与其他并发事务的交互方式。

1. **读未提交 (Read Uncommitted)**：在这个级别，事务可以读取其他事务未提交的数据。允许脏读、不可重复读和幻读。
2. **读已提交 (Read Committed)**：在这个级别，事务只能读取已经提交的数据。防止脏读，但允许不可重复读和幻读。
3. **可重复读 (Repeatable Read)**：在这个级别，一个事务在开始时看到的数据一致，即使其他事务在该事务执行过程中提交了数据。MySQL 的默认隔离级别是可重复读。防止脏读和不可重复读，但可能允许幻读。
4. **串行化 (Serializable)**：在这个级别，所有事务按顺序执行，完全避免并发问题。这会使系统性能下降，但可以避免“脏读”、“不可重复读”和“幻读”。

各个隔离级别之间的关系如下：

> 读未提交 < 读已提交 < 可重复读 < 串行化

MySQL 的默认事务隔离级别是“可重复读”，可以通过以下 SQL 命令查看和设置当前的隔离级别：

```sql
-- 查看当前会话的隔离级别
SELECT @@tx_isolation;

-- 设置当前会话的隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- 查看全局隔离级别
SELECT @@global.tx_isolation;

-- 设置全局隔离级别
SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
```

Spring Boot 中可以通过使用 @Transactional 注解指定某个方法的隔离级别。

如：

```java
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

@Service
public class YourService {

    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void yourTransactionalMethod() {
        // your transactional code
    }
}
```

在这个例子中，`yourTransactionalMethod` 方法的事务隔离级别被设置为 `READ_COMMITTED`。

Spring 提供的隔离级别枚举如下，对应于标准的 SQL 隔离级别：

- **Isolation.DEFAULT**：使用底层数据库的默认隔离级别。
- **Isolation.READ_UNCOMMITTED**：读未提交。
- **Isolation.READ_COMMITTED**：读已提交。
- **Isolation.REPEATABLE_READ**：可重复读。
- **Isolation.SERIALIZABLE**：串行化。

## 乐(悲)观锁

### 乐观锁 (Optimistic Lock)

**概念：**

乐观锁假设数据在并发环境下很少发生冲突，因此在操作数据时不加锁。乐观锁在提交更新时检查数据是否被其他事务修改，如果数据被修改，则回滚当前事务。

**特点：**

- **无锁操作**：在读取数据时不加锁，只在提交更新时检查冲突。
- **冲突检测**：通过比较版本号或时间戳来检测数据是否被修改。
- **性能较高**：由于没有频繁的加锁和解锁操作，系统性能较高。

适用场景：

- 数据争用不严重的场景。
- 读操作多于写操作的场景。
- 对性能要求较高的场景。

**实现方式：**

乐观锁通常使用版本号或时间戳机制。例如，在数据库表中添加一个 `version` 字段，每次更新时检查并递增版本号。以下是一个示例：

假设有一个 `accounts` 表：

```sql
CREATE TABLE accounts (
  id INT PRIMARY KEY,
  balance DECIMAL(10, 2),
  version INT
);
```

更新操作：

```sql
BEGIN;
SELECT balance, version FROM accounts WHERE id = 1;
/* Perform some business logic, e.g., balance += 100 */
UPDATE accounts SET balance = balance + 100, version = version + 1
WHERE id = 1 AND version = old_version;
COMMIT;
```

在更新时，检查 version 是否与读取时一致，如果不一致则更新失败，可以通过应用逻辑重试或报错处理。

### 悲观锁 (Pessimistic Lock)

**概念：**

悲观锁假设数据在并发环境下会发生冲突，因此在操作数据之前会锁定资源，以防止其他事务对数据进行修改。悲观锁通常依赖于数据库的锁机制。

**特点：**

- **加锁强度高**：在读取或写入数据之前，先对数据进行加锁，确保在事务结束之前，其他事务不能对数据进行操作。
- **阻塞性**：如果一个事务对数据加了悲观锁，其他尝试访问该数据的事务会被阻塞，直到锁被释放。
- **开销大**：由于频繁的加锁和解锁操作，会增加系统开销，影响性能。

**适用场景：**

- 数据争用严重的场景。
- 写操作频繁的场景。
- 对数据一致性要求极高的场景。

**实现方式：**

在 SQL 中可以使用 `SELECT ... FOR UPDATE` 来实现悲观锁。例如：

```sql
BEGIN;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
/* Perform updates */
COMMIT;
```

### 乐(悲)观锁总结

- **悲观锁**：通过加锁确保数据一致性，适用于高争用环境，但性能开销较大。
- **乐观锁**：通过版本控制或时间戳检测数据冲突，适用于低争用环境，性能较好，但需要处理冲突。

选择使用哪种锁机制，应根据具体应用的并发情况、数据访问模式和性能需求来决定。

## MVCC（多版本并发控制）

多版本并发控制 (MVCC, Multi-Version Concurrency Control) 是一种用于数据库管理系统的并发控制机制，它允许多个事务并发地执行而不会互相阻塞，同时提供一致的读和写操作。MVCC 通过维护数据的多个版本来实现，避免了许多传统锁机制带来的性能开销。

### MVCC 的工作原理

MVCC 通过为每个数据项保存多个版本，并为每个事务分配一个唯一的时间戳或事务 ID (Transaction ID, TID)，来管理并发事务。以下是 MVCC 的主要工作原理：

1. **版本链**：
   每个数据项都有一个版本链，链中包含该数据项的所有历史版本。每个版本包含数据值和相关的元数据（如创建时间戳和删除时间戳）。
2. **读取操作**：
   当事务读取数据时，它会查找与自己的时间戳匹配的最新版本。这意味着事务只会看到在其开始之前已经提交的版本，不会被其他并发事务未提交的修改所影响。
3. **写入操作**：
   当事务修改数据时，它不会覆盖现有版本，而是创建一个新版本，并将其添加到版本链中。新版本会带有事务的时间戳，表明它是由该事务创建的。
4. **提交和回滚**：
   当事务提交时，创建的新版本会成为可见版本。如果事务回滚，创建的新版本会被标记为无效，不会影响其他事务。

### MVCC 的优点

1. **减少锁竞争**：
   由于读操作不会阻塞写操作，写操作也不会阻塞读操作，MVCC 有效地减少了锁竞争，提高了系统的并发性能。
2. **一致性读取**：
   事务在读取数据时，总是能够看到一致的视图，不会被其他并发事务的未提交修改所影响，避免了脏读。
3. **提升性能**：
   由于读操作不需要加锁，系统的读性能得到显著提升。写操作创建新版本而不是覆盖旧版本，也提高了写操作的效率。

### MVCC 处理的并发问题

1. **避免脏读**：
   读操作只看到已经提交的数据版本，因此避免了读取未提交数据带来的脏读问题。
2. **避免不可重复读**：
   事务在读取同一数据项时，总是能够看到一致的版本，避免了同一事务中多次读取到不同数据的问题。
3. **幻读**：
   MVCC 在某些数据库系统中可以避免幻读问题。通过使用 MVCC 和合适的隔离级别（如可重复读或串行化），可以确保查询结果集的一致性。

### MVCC 的实现

不同数据库系统对 MVCC 的实现有所不同。以下是几种流行数据库的 MVCC 实现方式：

1. **PostgreSQL**：
   PostgreSQL 使用事务 ID (XID) 和隐藏字段来实现 MVCC。每个数据行都有两个隐藏字段，分别表示创建该行的事务 ID 和删除该行的事务 ID。
2. **MySQL (InnoDB 存储引擎)**：
   InnoDB 使用 undo log 和事务 ID 来实现 MVCC。每个数据行都有一个隐藏的事务 ID 和回滚指针，用于指向前一个版本的数据。
3. **Oracle**：
   Oracle 使用回滚段来存储旧版本的数据，当需要读取旧版本时，通过回滚段获取数据的历史版本。

### MVCC 总结

MVCC 是一种强大的并发控制机制，通过维护数据的多个版本，实现高效的并发事务处理。它有效地减少了锁竞争，提高了系统的性能和一致性，是现代数据库系统中广泛应用的技术。
